<!-- <!doctype html>
<meta charset="utf-8">
<title>Publisher</title>
<style>video{width:48%;background:#000;margin:4px}</style>
<h3>å‘å¸ƒç«¯ï¼ˆæ¨æµåˆ°æœåŠ¡å™¨ï¼‰</h3>
<button id="start">å¼€å§‹å‘å¸ƒ</button>
<button id="stop" disabled>åœæ­¢</button>
<div>
  <video id="local" autoplay playsinline muted></video>
  <video id="remote" autoplay playsinline></video>
</div>
<script>
let ws;
let pc, localStream;
let reconnectAttempts = 0;
const MAX_RECONNECT = 5;   // æœ€å¤§é‡è¿æ¬¡æ•°
const RECONNECT_INTERVAL = 2000; // æ¯æ¬¡é‡è¿é—´éš” 2s

// å»ºç«‹ WebSocket è¿æ¥
function initWebSocket() {
  const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${wsProto}://${location.host}/ws`);

  ws.onopen = () => {
    console.log("WebSocket connected.");
    reconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°
  };

  ws.onmessage = async (e) => {
    const msg = JSON.parse(e.data);
    if (msg.id === 'publishResponse') {
      await pc.setRemoteDescription(new RTCSessionDescription({type:'answer', sdp: msg.sdpAnswer}));
    } else if (msg.id === 'iceCandidate') {
      try { await pc.addIceCandidate(msg.candidate); } catch (err) { console.warn(err); }
    } else if (msg.id === 'error') {
      alert('Server error: ' + msg.message);
    }
  };

  ws.onclose = () => {
    console.warn("WebSocket closed.");
    attemptReconnect();
  };

  ws.onerror = (err) => {
    console.error("WebSocket error:", err);
    ws.close();
  };
}

// è‡ªåŠ¨é‡è¿é€»è¾‘
function attemptReconnect() {
  if (reconnectAttempts < MAX_RECONNECT) {
    reconnectAttempts++;
    console.log(`Reconnecting attempt ${reconnectAttempts}...`);
    setTimeout(initWebSocket, RECONNECT_INTERVAL);
  } else {
    console.error("Max reconnect attempts reached. Please refresh the page.");
  }
}

// å®‰å…¨å‘é€æ¶ˆæ¯
function safeSend(msg) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(msg));
  } else {
    console.warn("WebSocket not open, message dropped:", msg);
  }
}

// å¼€å§‹æ¨æµ
async function start() {
  document.getElementById('start').disabled = true;
  document.getElementById('stop').disabled = false;

  pc = new RTCPeerConnection({
    iceServers:[{urls:'stun:stun.l.google.com:19302'}]
  });

  pc.onicecandidate = ev => {
    if (ev.candidate) safeSend({id:'onIceCandidate', candidate: ev.candidate});
  };

  pc.ontrack = ev => { document.getElementById('remote').srcObject = ev.streams[0]; };

  localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
  document.getElementById('local').srcObject = localStream;
  for (const t of localStream.getTracks()) pc.addTrack(t, localStream);

  const offer = await pc.createOffer({offerToReceiveAudio:true, offerToReceiveVideo:true});
  await pc.setLocalDescription(offer);

  safeSend({id:'publish', sdpOffer: offer.sdp});
}

// åœæ­¢æ¨æµ
function stop() {
  safeSend({id:'stop'});
  if (pc) {
    pc.close();
    pc = null;
  }
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
}

document.getElementById('start').onclick = start;
document.getElementById('stop').onclick  = stop;

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ– WebSocket
initWebSocket();
</script> -->


<!doctype html>
<meta charset="utf-8">
<title>Publisher</title>
<style>video{width:48%;background:#000;margin:4px}</style>
<h3>å‘å¸ƒç«¯ï¼ˆæ¨æµåˆ°æœåŠ¡å™¨ï¼‰</h3>
<button id="start">å¼€å§‹å‘å¸ƒ</button>
<button id="stop" disabled>åœæ­¢</button>
<div>
  <video id="local" autoplay playsinline muted></video>
  <video id="remote" autoplay playsinline></video>
</div>
<script>
// WebSocker å»ºç«‹è¿æ¥ ï¼šæ ¹æ® ç½‘é¡µæ‰“å¼€åè®®é€‰æ‹© ç›¸åº” websocket åè®®
const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
const ws = new WebSocket(`${wsProto}://${location.host}/ws`);  // æ”¯æŒåŒå‘é€šä¿¡å®ç°

let pc, localStream, heartbeat; // pcï¼š RTCPeerConnectionå¯¹è±¡ï¼Œè¡¨ç¤ºæµè§ˆå™¨å’Œè¿œç«¯ï¼ˆKurentoï¼‰æœåŠ¡å™¨ä¹‹é—´çš„WebRTCè¿æ¥ localStream:æœ¬åœ°åª’ä½“æµï¼ˆæ‘„åƒå¤´å’Œéº¦å…‹é£ï¼‰
let statsTimerPub, lastBytesPub = 0, lastTimestampPub = Date.now();


// å¿ƒè·³ï¼šå®šæœŸå‘é€ ping ä¿æŒè¿æ¥
ws.onopen = () => {
  heartbeat = setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({id: "ping"}));
      console.log(`[Heartbeat] ping sent at ${new Date().toLocaleTimeString()}`);
    }
  }, 30000);
};

// WebSocket å…³é—­æ—¶æ¸…ç†å¿ƒè·³
ws.onclose = () => {
  clearInterval(heartbeat);
};

// å¤„ç†æœåŠ¡å™¨è¿”å›çš„æ¶ˆæ¯
ws.onmessage = async (e) => {
  const msg = JSON.parse(e.data);
  if (msg.id === 'publishResponse') {
    await pc.setRemoteDescription(new RTCSessionDescription({type:'answer', sdp: msg.sdpAnswer}));
  } else if (msg.id === 'iceCandidate') {
    try { await pc.addIceCandidate(msg.candidate); } catch (err) { console.warn(err); }
  } else if (msg.id === 'error') {
    alert('Server error: ' + msg.message);
  } else if (msg.id === 'pong') {
    console.log(`[Heartbeat] pong received at ${new Date().toLocaleTimeString()}`);
  }
};

// ---------- stats ç›‘æ§é€»è¾‘ï¼ˆæ¨æµç«¯ï¼‰ ----------
function startStatsMonitorPublisher() {
  if (statsTimerPub) clearInterval(statsTimerPub);
  lastBytesPub = 0; // ä¸Šä¸€æ¬¡ç»Ÿè®¡æ—¶çš„å·²å‘é€å­—èŠ‚æ•°
  lastTimestampPub = Date.now();  // ä¸Šä¸€æ¬¡ç»Ÿè®¡æ—¶çš„æ—¶é—´æˆ³

  statsTimerPub = setInterval(async () => {
    if (!pc) return;
    const stats = await pc.getStats();  // è·å–WebRTC è¿è¡Œæ—¶ç»Ÿè®¡ä¿¡æ¯
    stats.forEach(report => {
      if (report.type === "outbound-rtp" && report.kind === "video") {
        const now = Date.now();
        if (lastBytesPub > 0) {
          const bitrate = ((report.bytesSent - lastBytesPub) * 8) / ((now - lastTimestampPub) / 1000);   // report.bytesSent - lastBytesPub :æœ€è¿‘ä¸€æ®µæ—¶é—´å†…æ–°å‘é€çš„å­—èŠ‚æ•°
          console.log(`[${new Date().toLocaleTimeString()}] ğŸš€ æ¨æµç«¯ç ç‡: ${(bitrate/1000).toFixed(2)} kbps`);
        }
        lastBytesPub = report.bytesSent;  // ç´¯è®¡å‘é€çš„å­—èŠ‚æ•°
        lastTimestampPub = now;
      }
    });
  }, 5000);
}

function stopStatsMonitorPublisher() {
  if (statsTimerPub) clearInterval(statsTimerPub);
  statsTimerPub = null;
}


//å¼€å§‹æ¨æµ
async function start() 
{
  // ç¦ç”¨å¼€å§‹ï¼Œå¯ç”¨åœæ­¢
  document.getElementById('start').disabled = true;
  document.getElementById('stop').disabled = false;
  
  // åˆ›å»ºä¸€ä¸ª RTCPeerConnection ï¼Œé…ç½®STUNæœåŠ¡å™¨ï¼Œå¸®åŠ©ç©¿é€NAT
  pc = new RTCPeerConnection({
    iceServers:[{urls:'stun:stun.l.google.com:19302'}]
  });


  // å‡è®¾ä½ å·²ç»åˆ›å»ºäº† RTCPeerConnection å¯¹è±¡ pc
  pc.addEventListener('iceconnectionstatechange', () => {
    const state = pc.iceConnectionState;
    const now = new Date().toLocaleTimeString();

    console.log(`[${now}] ICE connection state changed: ${state}`);

    // å¦‚æœè¿æ¥æ–­å¼€ï¼Œé¢å¤–æç¤ºä¸€ä¸‹
    if (state === 'disconnected' || state === 'failed') {
      console.warn(`[${now}] âš ï¸ ICE è¿æ¥æ–­å¼€ï¼å¯èƒ½æ— æ³•ç»§ç»­æ‹‰æµ/æ¨æµ`);
    }
  });

  pc.addEventListener('connectionstatechange', () => {
    console.log(`[PC] connection state: ${pc.connectionState}`);
  });


  // æŠŠæœ¬åœ°æ”¶é›†åˆ°çš„å€™é€‰åœ°å€ï¼ˆICE Candidateï¼‰å‘ç»™æœåŠ¡å™¨ï¼Œç”±æœåŠ¡å™¨è½¬å‘ç»™å¯¹ç«¯
  pc.onicecandidate = ev => {
    if (ev.candidate) ws.send(JSON.stringify({id:'onIceCandidate', candidate: ev.candidate}));
  };

  // å¦‚æœæœåŠ¡å™¨æœ‰æµè¿”å›ï¼Œæ˜¾ç¤ºåœ¨è¿œç«¯videoæ ‡ç­¾
  pc.ontrack = ev => { document.getElementById('remote').srcObject = ev.streams[0]; };

  // è·å–æœ¬åœ°æ‘„åƒå¤´+éº¦å…‹é£ï¼Œæ˜¾ç¤ºåœ¨local video , å¹¶æ·»åŠ åˆ°è¿æ¥ä¸­
  localStream = await navigator.mediaDevices.getUserMedia({
    video:{ // æŒ‡å®šåˆ†è¾¨ç‡å’Œå¸§ç‡
      width: { min: 1920, ideal: 1920, max: 1920 },   // ç†æƒ³å®½åº¦
    height: { min: 1080, ideal: 1080, max: 1080 },   // ç†æƒ³é«˜åº¦
    frameRate: { ideal: 15 }, // ç†æƒ³å¸§ç‡
    },
    // true, 
    audio:true}); 
  document.getElementById('local').srcObject = localStream;
  
  for (const t of localStream.getTracks()) pc.addTrack(t, localStream);

  // ğŸš€ åœ¨ addTrack ä¹‹åï¼Œè®¾ç½® ç ç‡å‚æ•°
  pc.getSenders().forEach(sender => {
    if (sender.track && sender.track.kind === "video") {
      let params = sender.getParameters();
      if (!params.encodings) {
        params.encodings = [{}];
      }
      params.encodings[0].maxBitrate = 4_000_000; // 4 Mbps (å•ä½ï¼šbps)
      params.encodings[0].minBitrate = 1_000_000;   // ï¼Œé¿å…å¤ªç³Š
      sender.setParameters(params).then(() => {
        console.log("[WebRTC] è§†é¢‘å‚æ•°å·²è®¾ç½®:");
        console.log(" - åˆ†è¾¨ç‡: 1920x1080 @30fps");
        console.log(" - ç ç‡èŒƒå›´: 1Mbps ~ 4Mbps");
      }).catch(err => console.error("setParameters error", err));
    }
  });
  // // ğŸŸ¢ ä½¿ç”¨ Simulcastï¼šå¤šå±‚è§†é¢‘æµï¼ˆä½/ä¸­/é«˜ï¼‰
  // const videoTrack = localStream.getVideoTracks()[0];
  // pc.addTransceiver(videoTrack, {
  //   direction: "sendonly",
  //   sendEncodings: [
  //     { rid: "q", scaleResolutionDownBy: 4, maxBitrate: 500_000 },   // ä½æ¸…å±‚ 480p
  //     { rid: "h", scaleResolutionDownBy: 2, maxBitrate: 1_500_000 }, // é«˜æ¸…å±‚ 720p
  //     { rid: "f", scaleResolutionDownBy: 1, maxBitrate: 4_000_000 }  // å…¨é«˜æ¸…å±‚ 1080p
  //   ]
  // });

  // // æ·»åŠ éŸ³é¢‘è½¨é“
  // const audioTrack = localStream.getAudioTracks()[0];
  // if (audioTrack) pc.addTrack(audioTrack, localStream);
  
  // åˆ›å»ºoffer, è®¾ç½®ä¸ºæœ¬åœ°æè¿°ï¼Œç„¶åå‘ç»™æœåŠ¡å™¨ï¼Œè¯·æ±‚æ¨æµ
  const offer = await pc.createOffer({offerToReceiveAudio:true, offerToReceiveVideo:true});  // è®©æµè§ˆå™¨ç”Ÿæˆä¸€ä¸ª SDP offer (åŒ…å«æœ¬åœ°åª’ä½“èƒ½åŠ›ã€‚æ¯”å¦‚æ”¯æŒçš„éŸ³è§†é¢‘ç¼–è§£ç å™¨ï¼Œåˆ†è¾¨ç‡ã€æ¯”ç‰¹ç‡)
  await pc.setLocalDescription(offer);

  ws.send(JSON.stringify({id:'publish', sdpOffer: offer.sdp})); // é€šè¿‡websocket å°†SDP offer å‘é€ç»™æœåŠ¡å™¨Kurento,è¯·æ±‚å…¶ä½œä¸ºå¯¹ç«¯ç”ŸæˆSDp answer

  startStatsMonitorPublisher();
}

function stop() {
  ws.send(JSON.stringify({id:'stop'}));
  if (pc) pc.close();
  pc = null;
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }
  stopStatsMonitorPublisher();
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
}

document.getElementById('start').onclick = start;
document.getElementById('stop').onclick  = stop;
</script>
